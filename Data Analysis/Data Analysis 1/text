#Calculate the inter-quartile range (IQR) for age, height, and BMI for each gender and each MVU.
# Report the ratio between the largest and smalles IQR across the MVUs.
#We basically need to do the same but with the interquartile range
print("Females case")
daF = da.query('RIAGENDRx == @Female').copy()
age_IQR = daF.groupby(["SDMVSTRA", "SDMVPSU"])["RIDAGEYR"].quantile(0.75) - da.groupby(["SDMVSTRA", "SDMVPSU"])["RIDAGEYR"].quantile(0.25)
height_IQR = daF.groupby(["SDMVSTRA", "SDMVPSU"])["BMXHT"].quantile(0.75) - da.groupby(["SDMVSTRA", "SDMVPSU"])["BMXHT"].quantile(0.25)
BMI_IQR = daF.groupby(["SDMVSTRA", "SDMVPSU"])["BMXBMI"].quantile(0.75) - da.groupby(["SDMVSTRA", "SDMVPSU"])["BMXBMI"].quantile(0.25)
print("age IQR: \n", age_IQR, "\n," "height IQR: \n ",  height_IQR, "\n", "BMI IQR: \n ", BMI_IQR)

print("Male case")
daM = data_pool = da.query('RIAGENDRx == @Male').copy()
age_IQR = daM.groupby(["SDMVSTRA", "SDMVPSU"])["RIDAGEYR"].quantile(0.75) - da.groupby(["SDMVSTRA", "SDMVPSU"])["RIDAGEYR"].quantile(0.25)
height_IQR = daM.groupby(["SDMVSTRA", "SDMVPSU"])["BMXHT"].quantile(0.75) - da.groupby(["SDMVSTRA", "SDMVPSU"])["BMXHT"].quantile(0.25)
BMI_IQR = daM.groupby(["SDMVSTRA", "SDMVPSU"])["BMXBMI"].quantile(0.75) - da.groupby(["SDMVSTRA", "SDMVPSU"])["BMXBMI"].quantile(0.25)
print("age IQR: \n", age_IQR, "\n," "height IQR: \n ",  height_IQR, "\n", "BMI IQR: \n ", BMI_IQR)

print("Females case")
daF = da.query('RIAGENDRx == "Female"').copy()
MVU1_values_list = sorted(daF['SDMVSTRA'].dropna().unique().tolist())  #creates a list with the unique values RIAGENDR assumes
MVU2_values_list =  sorted(daF['SDMVPSU'].dropna().unique().tolist())
#print(MVU2_values_list, MVU1_values_list)
three_items = ["RIDAGEYR", "BMXHT", "BMXBMI"]
for variable in three_items:
    lowest = float('inf') #infinty
    highest = float('-inf')
    #print("We now search the smallest and highest mean for", variable)
    for value1 in MVU1_values_list:
        for value2 in MVU2_values_list:
            data_pool = da.query('SDMVSTRA == @value1 and SDMVPSU == @value2').copy()
            IQR = data_pool[variable].quantile(0.75) - data_pool[variable].quantile(0.25)
            if IQR < lowest:
                lowest = IQR
            rounded_lowest = np.round(lowest, 3)
            if IQR > highest: #not elif because i may exit the loop for good, using the first if, if they are in order
                highest = IQR
            rounded_highest = np.round(highest, 3)
            print("The highest and lowest IQR in", variable, "in the section SDMVSTRA =",
                  value1, "and SDMVPSU =", value2, "are:", rounded_highest, rounded_lowest)

daM = data_pool = da.query('RIAGENDRx == @Male').copy()
MVU1_values_list = sorted(daM['SDMVSTRA'].dropna().unique().tolist())  #creates a list with the unique values RIAGENDR assumes
MVU2_values_list =  sorted(daM['SDMVPSU'].dropna().unique().tolist())
#print(MVU2_values_list, MVU1_values_list)
three_items = ["RIDAGEYR", "BMXHT", "BMXBMI"]
for variable in three_items:
    lowest = float('inf') #infinty
    highest = float('-inf')
    #print("We now search the smallest and highest mean for", variable)
    for value1 in MVU1_values_list:
        for value2 in MVU2_values_list:
            data_pool = da.query('SDMVSTRA == @value1 and SDMVPSU == @value2').copy()
            IQR = data_pool[variable].quantile(0.75) - data_pool[variable].quantile(0.25)
            if IQR < lowest:
                lowest = IQR
            rounded_lowest = np.round(lowest, 3)
            if IQR > highest: #not elif because i may exit the loop for good, using the first if, if they are in order
                highest = IQR
            rounded_highest = np.round(highest, 3)
            print("The highest and lowest IQR in", variable, "in the section SDMVSTRA =",
                  value1, "and SDMVPSU =", value2, "are:", rounded_highest, rounded_lowest)


da_q3 = da.groupby(['SDMVPSU', 'SDMVSTRA']).quantile(.75, numeric_only=True)
da_q1 = da.groupby(['SDMVPSU', 'SDMVSTRA']).quantile(.25, numeric_only=True)

# calculate the IQR for RIDAGEYR, BMXHT and BMXBMI
da_iqr = da_q3 - da_q1

# calculate and print the BMXHT iqr ratio
ratio_height_iqr = da_iqr['BMXHT'].max()/da_iqr['BMXHT'].min()
print("Males")
print(round(ratio_height_iqr, 3), " (Height)")

# calculate and print the RIDAGEYR iqr ratio
ratio_age_iqr = da_iqr['RIDAGEYR'].max()/da_iqr['RIDAGEYR'].min()
print(round(ratio_age_iqr, 3), " (Age)")

# calculate and print the BMXBMI iqr ratio
ratio_bmi_iqr = da_iqr['BMXBMI'].max()/da_iqr['BMXBMI'].min()
print(round(ratio_bmi_iqr, 3), " (BMI)")

# Females

# calculate the 2nd and 3rd quintiles for RIDAGEYR, BMXHT and BMXBMI across MVUs
da_q3 = daf.groupby(['SDMVPSU', 'SDMVSTRA']).quantile(.75, numeric_only=True)
da_q1 = daf.groupby(['SDMVPSU', 'SDMVSTRA']).quantile(.25, numeric_only=True)

# calculate the IQR for RIDAGEYR, BMXHT and BMXBMI
da_iqr = da_q3 - da_q1

# calculate and print the BMXHT iqr ratio
ratio_height_iqr = da_iqr['BMXHT'].max()/da_iqr['BMXHT'].min()
print("\nFemales")
print(round(ratio_height_iqr, 3), " (Height)")

# calculate and print the RIDAGEYR iqr ratio
ratio_age_iqr = da_iqr['RIDAGEYR'].max()/da_iqr['RIDAGEYR'].min()
print(round(ratio_age_iqr, 3), " (Age)")

# calculate and print the BMXBMI iqr ratio
ratio_bmi_iqr = da_iqr['BMXBMI'].max()/da_iqr['BMXBMI'].min()
print(round(ratio_bmi_iqr, 3), " (BMI)")

